library(roxygen2)
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::build()
usethis::use_gpl3_license()
devtools::document()
devtools::check()
knitr::opts_chunk$set(collapse = T, comment = "#>")
options(tibble.print_min = 4L, tibble.print_max = 4L)
library(ridgeRegression)
set.seed(123)
library(MASS)
x <- matrix(rnorm(100 * 20), 100, 20)
y <- rnorm(100)
fit <- ridgeRegression(x, y, 0.5)
fit_standard <- lm.ridge(y~x-1, lambda = 0.5 * 100 / 99)
x <- matrix(rnorm(100 * 20), 100, 20)
y <- rnorm(100)
fit <- ridgeRegression(x, y, 0.5)
fit_standard <- lm.ridge(y~x-1, lambda = 0.5 * 100 / 99)
all.equal(fit$0.5, coef(fit_standard))
View(fit)
View(fit)
x <- matrix(rnorm(100 * 20), 100, 20)
y <- rnorm(100)
fit <- ridgeRegression(x, y, 0.5)
fit_standard <- lm.ridge(y~x-1, lambda = 0.5 * 100 / 99)
all.equal(fit$'0.5', coef(fit_standard))
knitr::opts_chunk$set(collapse = T, comment = "#>")
options(tibble.print_min = 4L, tibble.print_max = 4L)
library(ridgeRegression)
library(MASS)
set.seed(123)
fit$0.5
fit$`0.5`
x <- matrix(rnorm(100 * 20), 100, 20)
y <- rnorm(100)
fit <- ridgeRegression(x, y, 0.5)
fit_standard <- lm.ridge(y~x-1, lambda = 0.5 * 100 / 99)
all.equal(fit$`0.5`, coef(fit_standard))
typeof(fit$`0.5`)
typeof(coef(fit_standard))
coef(fit_standard)
as.vector(fit$`0.5`)
ridgeRegression <- function(X, Y, lambdas) {
# Error handling
stopifnot(is.matrix(X))
stopifnot(is.vector(Y))
stopifnot(is.vector(lambdas))
stopifnot(all(lambdas >= 0))
stopifnot(nrow(X) == length(Y))
# Standardize the data
X = scale(X, T, T)
Y = scale(Y, T, T)
coefs = list()
for(lambda in lambdas) {
if ((ncol(X) - nrow(X)) > 10^2) {
# Faster operation if p >> n in X
U <- chol(tcrossprod(X) + diag(lambda, nrow(X)))
z <- forwardsolve(U, Y, upper.tri=TRUE, transpose=TRUE)
beta <- t(X) %*% backsolve(U, z)
coefs = c(coefs, vector(beta))
} else {
# Cholesky decomposition can be faster than manually calculating the inverse
tXY <- crossprod(X, Y)
U <- chol(crossprod(X) + diag(lambda, ncol(X)))
z <- forwardsolve(U,tXY,upper.tri=TRUE,transpose=TRUE)
beta <- backsolve(U,z)
coefs = c(coefs, vector(beta))
}
}
names(coefs) = lambdas
return(coefs)
}
x <- matrix(rnorm(100 * 20), 100, 20)
y <- rnorm(100)
fit <- ridgeRegression(x, y, 0.5)
ridgeRegression <- function(X, Y, lambdas) {
# Error handling
stopifnot(is.matrix(X))
stopifnot(is.vector(Y))
stopifnot(is.vector(lambdas))
stopifnot(all(lambdas >= 0))
stopifnot(nrow(X) == length(Y))
# Standardize the data
X = scale(X, T, T)
Y = scale(Y, T, T)
coefs = list()
for(lambda in lambdas) {
if ((ncol(X) - nrow(X)) > 10^2) {
# Faster operation if p >> n in X
U <- chol(tcrossprod(X) + diag(lambda, nrow(X)))
z <- forwardsolve(U, Y, upper.tri=TRUE, transpose=TRUE)
beta <- t(X) %*% backsolve(U, z)
coefs = c(coefs, list(beta))
} else {
# Cholesky decomposition can be faster than manually calculating the inverse
tXY <- crossprod(X, Y)
U <- chol(crossprod(X) + diag(lambda, ncol(X)))
z <- forwardsolve(U,tXY,upper.tri=TRUE,transpose=TRUE)
beta <- backsolve(U,z)
coefs = c(coefs, list(beta))
}
}
names(coefs) = lambdas
return(coefs)
}
x <- matrix(rnorm(100 * 20), 100, 20)
y <- rnorm(100)
fit <- ridgeRegression(x, y, 0.5)
fit_standard <- lm.ridge(y~x-1, lambda = 0.5 * 100 / 99)
all.equal(as.vector(fit$`0.5`), coef(fit_standard))
as.vector(fit$`0.5`)
coef(fit_standard)
knitr::opts_chunk$set(collapse = T, comment = "#>")
options(tibble.print_min = 4L, tibble.print_max = 4L)
library(ridgeRegression)
library(MASS)
set.seed(123)
x <- matrix(rnorm(100 * 20), 100, 20)
y <- rnorm(100)
fit <- ridgeRegression(x, y, 0.5)
fit_standard <- lm.ridge(y~x-1, lambda = 0.5 * 100 / 99)
all.equal(as.vector(fit$`0.5`), coef(fit_standard))
as.vector(fit$`0.5`)
coef(fit_standard)
?lm.ridge
x <- matrix(rnorm(100 * 20), 100, 20)
y <- rnorm(100)
fit <- ridgeRegression(x, y, 0.5)
fit_standard <- lm.ridge(scale(y, T, T)~scale(x, T, T) -1, lambda = 0.5 * 100 / 99)
all.equal(as.vector(fit$`0.5`), coef(fit_standard))
coef(fit_standard)
as.vector(fit$`0.5`)
x <- matrix(rnorm(100 * 20), 100, 20)
y <- rnorm(100)
fit <- ridgeRegression(x, y, 0.5)
fit_standard <- lm.ridge(scale(y, T, T)~scale(x, T, T) -1, lambda = 0.5 * 100 / 99)
all.equal(as.vector(fit$`0.5`), as.vector(coef(fit_standard)))
install.packages("bench")
install.packages("bench")
knitr::opts_chunk$set(collapse = T, comment = "#>")
options(tibble.print_min = 4L, tibble.print_max = 4L)
library(bench)
library(MASS)
library(ridgeRegression)
install.packages("ridgeRegression_0.1.0.tar.gz",repos=NULL)
knitr::opts_chunk$set(collapse = T, comment = "#>")
options(tibble.print_min = 4L, tibble.print_max = 4L)
require(bench)
require(MASS)
library(ridgeRegression)
usethis::use_github_action()
usethis::use_github_action()
?expect_error
?testthat::expect_error
library(ridgeRegression)
x = matrix(rnorm(100*20), 100, 20)
ridgeRegression(x, x, 0.5)
devtools::test()
use_test()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
